# รายงานปฏิบัติการที่ 7 (Lab 07)

**ชื่อ - นามสกุล :** วราวุฒิ จำนงค์ผล
**รหัสนิสิต :** 67160197

---

## 1.6 ตอบคำถามเพื่อวัดความเข้าใจ

### 1. querySelector vs querySelectorAll: อะไรคือความแตกต่าง

- **querySelector() ใช้เมื่อไร:**
  - ตอบ : ใช้เมื่อต้องการเลือก Element ตัวแรกที่เจอเพียงตัวเดียว
- **querySelectorAll() ใช้เมื่อไร:**
  - ตอบ : ใช้เมื่อต้องการเลือก Element ทั้งหมดที่ตรงตามเงื่อนไข คืนค้่าเป็น NodeList

### 2. classList.toggle(): nav.classList.toggle('hidden') ทำงานอย่างไร

- **ถ้า nav มี class 'hidden' แล้ว toggle() จะทำอะไร:**
  - ตอบ : มันจะลบ class 'hidden' ออก จากที่ทำมาทำให้ nav แสดงผล
- **ถ้า nav ไม่มี class 'hidden' แล้ว toggle() จะทำอะไร:**
  - ตอบ : มันจะเพิ่ม class 'hidden' เข้าไป จากที่ทำมาทำให้ nav ถูกซ่อนไว้

### 3.event.target: เมื่อคลิกปุ่ม event.targetจะชี้ไปที่อะไร

- ตอบ : เมื่อคลิกที่ปุ่ม event.target จะชีไปที่ตัวของ element ที่ถูกคลิกไปจริงๆ

### 4.remove() vs toggle(): เมื่อคลิก link ควร ใช้nav.classList.remove('hidden') หรือ nav.classList.toggle('hidden')? ทําไม

- ตอบ : ใช้งาน nav.classList.remove('hidden') เพราะว่าเราต้องการเมื่อคลิกlinkนั้นไม่ใช่การสลับไปมา เวลาเราคลิก link เลือกเมนูแล้ว มันควรจะหายไป เมนูควรปิดลงแน่นอนเพื่อให้ไปยังเนื้อหา ไม่ใช่สลับสถานะไปมา

### 5.display: none: .hidden { display: none; } ทําไมจึงจําเป็น? วิธีอื่นเพื่อซ่อน element ได้หรือไม่

- ตอบ : จำเป็นเพราะว่า เพื่อให้ element หายไปจากหน้าจอและไม่กินพื้นที่
- มีวิธีอื่นเพื่อซ่อนได้ : visibility: hidden ซ่อนได้แต่ยังกินพื้นที่อยู่ , opacity: 0 กินพื้นที่เท่าเดิม และยังสามารถคลิกได้

---

## 2.6 ตอบคําถามต่อไปนี้เพื่อวัดความเข้าใจ

### 1. Event Delegation: ทำไมเราต้องใช้ event delegation สำหรับ todo list?

- ตอบ : เพราะ todo list มีการสร้าง element ใหม่แบบ dynamic ถ้าไปติด listener ที่ปุ่มแต่ละตัว จะยุ่งยากและเปลืองทรัพยากรใช้ delegation โดยติด listener ที่ paren จะจัดการปัญหาได้โดยไม่ต้องเพิ่ม listener ใหม่ทุกครั้ง

### 2. event.target: ใน event delegation event.targetชี้ไปที่อะไร? element ที่คลิก หรือ element ที่มี listener

- ตอบ : event.target จะชี้ไปที่ element ที่ถูกคลิกจริง ๆ (actual clicked element) ไม่ใช่ element ที่ติด listener เช่น ในตัวอย่าง event.target จะเป็นปุ่ม .delete-btn เมื่อผู้ใช้คลิกปุ่มลบ แม้ว่า event listener จะถูกผูกไว้ที่ todoList ก็ตาม

### 3. innerHTML: ทําไมต้องใช้li.innerHTML = '<span>...</span><button>...</button>'แทน li.textContent = 'text'

- ตอบ : เพราะว่าสามารถสร้างโครงสร้างภายใน li ได้เช่นมีทั้งข้อความและปุ่ม delete อยู่ใน element เดียวกัน แตกต่างจาก li.textContent = 'text' ใส่ข้อความดิบ ๆ เท่านั้น ไม่สามารถมีโครงสร้าง HTML ได้

### 4. New Elements: ถ้าเพิ่ม todo ใหม่หลังจาก page โหลด delete button ยังใช้งานได้ไหม ทําไม

- ตอบ : ยังใช้งานได้ปกติเพราะเราใช้ event delegation ที่ parent element ซึ่งจะตรวจจับการคลิกของปุ่มใหม่ๆโดยอัตโนมัติ

### 5. if (!text) return: Code นี้ทําอะไร? ถ้าไม่มี code นี้จะเกิดอะไร

- ตอบ : เป็นเงื่อนไขตรวจสอบถ้า text เป็นค่าว่างจะหยุดการทำงาน ไม่สร้าง li ใหม่ แต่ถ้าหากไม่มีcodeนี้เกิด li เปล่า ๆ ที่ไม่มีข้อความ ทำให้ list ดูไม่สมบูรณ์และรก

### 6. trim(): ทําไมต้องใช้.trim() ก่อนตรวจสอบว่าว่างไหม

- ตอบ : ใช้เพื่อตัดช่องว่างหน้า-หลังข้อความออกก่อนตรวจสอบ เช่น " " จะกลายเป็น "" ถ้าไม่ได้ใช้งาน.trim()สามารถใส่ช่องว่างล้วน ๆ แล้วระบบคิดว่ามีข้อความ

---

## 3.6 ตอบคําถามต่อไปนี้เพื่อวัดความเข้าใจ

### 1. 'input' vs 'change' event: ต่างกันอย่างไร? ทําไมต้องใช้ 'input' สําหรับ real-time validation

- ตอบ : input นั้นเกิดขึ้นทุกครั้งที่มีค่าของ input เปลี่ยนแปลงไป แต่ change เกิดขึ้นจากผู้ใช้เปลี่ยนแปลงค่าของข้อมูล และทำให้ input นั้นเหมาะสมกับreal-time validationเพราะว่าตรวจสอบได้ทันทีที่ผู้ใช้พิมพ์ แต่changeนั้นช้ากว่ามากจึงไม่แนะนำ

### 2. preventDefault(): ทําอะไร? ถ้าไม่มี code นี้จะเกิดอะไร

- ตอบ : ป้องกันพฤติกรรมเริ่มต้นของ browser เช่นการ submit form แล้วรีเฟรชหน้าซ้ำ แต่ถ้าไม่มี เมื่อsummitทำให้validation ฝั่ง client ไม่ทำงานตามที่ตั้งใจ

### 3. classList operations: ทําไมต้อง remove('error') และ add('valid') ทั้งคู่? ไม่ได้มี add('valid') คนเดียวไหม

- ตอบ : ไม่ได้ต้อง remove('error') ด้วยเพื่อให้แน่ใจว่า class error ถูกลบออกไปก่อน แต่ถ้าใช้แค่ add('valid') element อาจทำให้มีทั้ง error และ valid พร้อมกันเกิดปัญหาทำให้ style หรือ logic สับสน

### 4. disabled attribute: submitBtn.disabled = true หมายความว่าอะไร? สามารถจัดการผ่าน JavaScript ได้ไหม

- ตอบ : หมายความถึงปุ่ม submit ถูกปิดใช้งาน ไม่สามารถกดอะไรได้ สามารถจัดการได้ เช่น submitBtn.disabled = false เพื่อเปิดใช้งานอีกครั้งหลัง validation ผ่าน

### 5. Email validation: value.includes('@') && value.includes('.') กรณีไหนจะผิด

- **"user@gmail..com" (2 dots) - ผ่านหรือไม่**
  - ตอบ : ผ่าน เงื่อนไข includes เพราะมี @ และ . แต่จริง ๆ เป็น email ไม่ถูกต้อง
- **"user.gmail.com" (ไม่มี @) - ผ่านหรือไม่**
  - ตอบ : ไม่ผ่าน เพราะไม่มี @ ตามเงื่อนไข

### 6. DRY principle: ทําไม code ที่เพิ่ม listener 4 ครั้ง (สําหรับ 4 inputs) ทําให้ code ยาว

- ตอบ : เพราะการเพิ่ม event listener แยก 4 ครั้ง ทำให้ต้องเขียนโค้ดซ้ำหลายบรรทัด ซึ่งขัดกับหลัก DRY (Don't Repeat Yourself) ที่ต้องการลดความซ้ำซ้อนของโค้ด หากมีการแก้ไข logic จะต้องแก้หลายจุด เสี่ยงเกิดข้อผิดพลาดและทำให้โค้ดยาว อ่านยาก และดูแลรักษายาก ดังนั้นควรใช้การวนลูปหรือฟังก์ชันร่วมเพื่อลดการเขียนซ้ำ

### 7. confirm-password field: ทําไมต้องมี? ถ้าลบออกจะเกิดปัญหาไหม

- ตอบ : มีเพื่อให้ผู้ใช้ยืนยันรหัสผ่านอีกครั้ง ลดความผิดพลาดจากการพิมพ์ผิด ถ้าเกิดลบออกไป เวลาผู้ใช้พิมพ์รหัสผิดโดยไม่รู้ตัว อาจล็อกอินไม่ได้หรือเกิดปัญหาความปลอดภัย ควรมีเพื่อความปลอดภัยในการใช้งาน

---
